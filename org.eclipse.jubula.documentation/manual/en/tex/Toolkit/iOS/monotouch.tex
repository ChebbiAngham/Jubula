\subsubsection{Create a binding project}
First you have to create a MonoTouch Binding Project. The project template can be found in the category \emph{C\#/MonoTouch}.
A binding project contains a reference to the MonoTouch library as well as two C\# files called \emph{ApiDefinition.cs} and \emph{StructsAndEnums.cs}.

\subsubsection{Add the library to the binding project}
Add the library file librc.mobile.ios.nativ.a to the new binding project. The file is part of the archive \bxname{development/iOS-support.zip} in the installation directory.

MonoDevelop will ask either to copy, move or link the file in the binding project. We recommend choosing copy because MonoDevelop will place a generated C\# file called \textit{librc.mobile.ios.nativ.linkwith.cs} next to the library file.

\subsubsection{Setting up linker options}
The file \textit{librc.mobile.ios.nativ.linkwith.cs} specifies the linker options. It contains a single annotation named \textit{LinkWith}.
Change the annotation to:\\
\begin{verbatim}
[assembly: LinkWith 
("librc.mobile.ios.nativ.a", 
LinkTarget.Simulator | LinkTarget.ArmV6 
| LinkTarget.ArmV7,
 "-ObjC -all_load", ForceLoad = true, 
Frameworks="CFNetwork")
\end{verbatim}
 
Doing this allows your \gdaut{} to be tested on the simulator as well as on iOS devices. The framework \textit{CFNetwork} is needed to communicate with the \ite{}.

\subsubsection{Defining the API contract}
An Objective-C header file is provided. To use the library from within a .NET project, you have to link the library's interface parts to .NET structures.

Linking is done in the file \textit{ApiDefinition.cs}. You have to translate the header file contents into some C\# interfaces. Finally you have to annotate the interfaces/methods/parameters that name the library's objects.

Detailed information about translation and annotation may be found on Xamarins web site: 
\url{http://docs.xamarin.com/ios/Guides/Advanced\_Topics/Binding\_Objective-C\_Libraries}.

To use the library, adapt the following:

\tablehead{\hline\textbf{Library's header file content}&\textbf{Linking in ApiDefiniton.cs}\\\hline}
\begin{supertabular}{|p{6.0cm}p{6.0cm}|}
\hline
      @interface ObjCClass\\... 
      & [BaseType (typeof (NSObject))] \\ 
      & interface ObjCClass \{ \\
\hline
      @end & ... \\ 
      & \}\\
\hline
      +(void)method1:(int)parameter; 
      & [Static, Export(''method1:'')] \\ 
     & void method1(int parameter);\\
\hline
      -(NSString$\ast$)method2; 
      & [Export''method2'')] \\ 
      & NSString method2();\\
\hline
      @protocol MyDelegate \\
      -(int)method3; \\ 
       @end 
      & [BaseType (typeof(NSObject))] \\ 
      & [Model] \\
      & interface MyDelegate \{\\ 
      & [Export(''method3'')] \\ 
      & [Abstract] \\ 
      & int method3();\\ 
      & \}\\
\hline
\end{supertabular}

\subsubsection{Building a .NET library}

When linking is done, build the binding project in Release mode. When it is done, you will find a DLL in the bin/Release directory of the binding project.

Copy this DLL to your project for your \gdaut{} and add it as a reference to a .NET Assembly.

When the library changes, we recommend to remove this reference and repeat the entire process.

\subsubsection{Add hook into \gdaut{}}
When the binding DLL is referenced by your project, you can use the namespace and all interfaces defined in \emph{ApiDefinition.cs}.
Adding the hook is the same as described for native iOS Apps but using C\# syntax. You should omit the preprocessor macros mentioned there or implement your own switch for enabling the test hook.

Native iOS Apps are required to provide a ''window'' property in the AppDelegate. Your C\# AppDelegate has to provide and use this property too:
\begin{verbatim}
[Export("window")]
UIWindow window { get; set; }
\end{verbatim}
