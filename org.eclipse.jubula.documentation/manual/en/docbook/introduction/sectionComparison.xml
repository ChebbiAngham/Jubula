<section id="comparison-to-other-testing-approaches" version="5.0" xmlns="http://docbook.org/ns/docbook"
                                                                   xmlns:xi="http://www.w3.org/2001/XInclude"
                                                                   xmlns:xl="http://www.w3.org/1999/xlink" >
  <title>Comparison to other testing approaches</title>
  <para>
    Testing is critical to the success of software projects. It is
    especially important to acceptance test software which is designed
    for end users.
  </para>
  <para>
    There are various ways to go about performing acceptance testing,
    each with their advantages and disadvantages.
  </para>
  <section id="manual-tests">
    <title>Manual Tests</title>
    <para>
      Manual testing, although thorough, cannot keep up with the pace
      of development. It is impossible to carry out complete
      continuous integration and regression tests manually.
    </para>
  </section>
  <section id="programmed-tests">
    <title>Programmed Tests</title>
    <para>
      Writing tests in some kind of scripting language is certainly
      powerful, but it puts a strain on the resources of a team,
      because the test code itself becomes a project in its own right
      and also needs to be checked and maintained. The extra costs
      added by programming GUI tests can be considerable.
    </para>
    <para>
      Tests written in code also have the problem that they no longer
      view the software as a black box and may miss important aspects
      relating to the acceptance. In addition, automation experts
      (experienced software developers) become the only people who can
      write or maintain tests. It is generally inadvisable to test
      your own work, but this is what can happen if testing remains
      solely in the realm of the developers. Writing tests without
      coding from the black box perspective not only allows test
      experts to automate tests (and therefore brings the test
      perspective to the forefront), but also puts developers in the
      shoes of the users, which helps to focus and improve the test.
    </para>
  </section>
  <section id="recorded-tests">
    <title>Recorded Tests</title>
    <para>
      Possibly the most popular approach to automated functional
      testing is macro recording, that is, recording a user’s actions
      for later playback. The appeal of this approach is the
      apparently quick success that can be seen: a test script can be
      quickly recorded and played back, giving the impression that
      automated testing is nothing more than recording a manual test.
    </para>
    <para>
      However, this approach fails to meet the needs of large or
      long-term software projects for the following reasons:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Test specification begins very late in the development
          cycle, as recording can only begin once the software is
          available.
        </para>
      </listitem>
      <listitem>
        <para>
          Since only the user action is recorded, checkpoints for
          verification of test results have to be inserted manually.
        </para>
      </listitem>
      <listitem>
        <para>
          Recorded tests can only test parts of the application which
          already work.
        </para>
      </listitem>
      <listitem>
        <para>
          There is also the danger that the implementation of the
          application will be tested, instead of the requirements.
        </para>
      </listitem>
      <listitem>
        <para>
          Recorded scripts are often very large and not particularly
          well-structured. Making changes at a later point is
          therefore difficult and requires programming skills, which
          further increases costs.
        </para>
      </listitem>
      <listitem>
        <para>
          Code generated by recording generally doesn’t conform to
          common software quality attributes such as reliability,
          stability, portability, maintainability, and usability.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      In essence, a recorded script is not an automated test. It must
      be refactored to remove errors and redundancies, to make its
      component parts modular and reusable and to insert the
      intelligence of the manual tester to make the test robust. Once
      all this has been done, there is probably very little of the
      original recording left, and a great deal of development work
      has been done to refactor the script.
    </para>
  </section>
  <section id="our-approach">
    <title>Our approach</title>
    <para>
      Our approach lets you automate tests which follow the best
      practices known from software development (readability,
      modularity and reusability to ensure maintainability), but
      without any programming effort.
    </para>
    <para>
      This gives the following advantages:
    </para>
    <section id="early-test-creation">
      <title>Early test creation</title>
      <para>
        Tests are created before the AUT is available. This is a radical advantage over capture-replay tools, which force testers to wait until an application is ready to begin with testing. The specification of modular, flexible GUI tests begins early (even as early as at the requirements stage) and continues alongside software development.
      </para>
      <para>
        The benefit of this is that every version of an AUT can be tested as soon as it becomes available. Testing keeps up with development, so you waste no time in your test process. Earlier testing lets you find issues when they are cheaper and easier to fix and encourages collaboration and communication within the team.
      </para>
    </section>
    <section id="code-free-automation">
      <title>Code-free automation</title>
      <para>
        Tests are automated completely from the user perspective and require no programming effort.
      </para>
      <para>
        This means that those who understand the user perspective best
        are able to fully automate tests. There is no need to wait for
        input (e.g. programmatic creation of test modules) from other
        team members to automate a test. If developers are writing
        tests, the black box perspective encourages them to think like a
        user would when faced with the software. Code-free tests also
        have the advantage that they are readable by the whole team and
        also by users or customers.
      </para>
    </section>
    <section id="manual-tester-intelligence">
      <title>Manual tester intelligence</title>
      <para>
        The wide range of keywords available include high-level actions
        which can be meaningfully used by testers. There is also a wide
        range of check and synchronization actions to incorporate the
        necessary robustness into a test.
      </para>
    </section>
  </section>
</section>