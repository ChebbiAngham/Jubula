<section id="approaches-to-testing" version="5.0" xmlns="http://docbook.org/ns/docbook"
                                                  xmlns:xi="http://www.w3.org/2001/XInclude"
                                                  xmlns:xl="http://www.w3.org/1999/xlink" >
  <title>Approaches to testing</title>
  <para>
    Modular testing is supported by the ITE. You can either create
    modules in advance and combine them to make larger Test Cases, or
    you can create modules from existing Test Cases when you realize
    you need them.
  </para>
  <section id="writing-modules-in-advance">
    <title>Writing modules in advance</title>
    <para>
      If you can identify which reusable modules a test will require
      in advance, then you can specify them in a general or abstract
      way, making them easy to adapt and reuse.
    </para>
    <para>
      These small units are used to construct other modules or
      building blocks, which are more adapted to the task at hand.
      Concrete details can be added as needed.
    </para>
    <para>
      One of the advantages of this approach is that tests are
      flexible and easy to maintain, since a change made at a central
      point can update many places where that Test Case has been
      reused. Tests are also generally more efficient, because time is
      not wasted specifying what is essentially the same Test Case
      over and over again.
    </para>
    <para>
      The difficulty with this approach testing is that it requires a
      good knowledge of the structure of the test – you have to know
      which Test Cases are going to be required multiple times, and
      this is often not easy to recognize at the beginning of testing.
    </para>
  </section>
  <section id="creating-modules-from-existing-test-cases">
    <title>Creating modules from existing Test Cases</title>
    <para>
      It is often initially more intuitive to start writing a test in
      a linear fashion, adding steps as necessary. Each step is
      specified for the current purpose, and contains all the
      necessary details (e.g. data).
    </para>
    <para>
      The possible problem with this method is that similar or
      identical parts are often separately and multiply specified,
      which means that making changes at a later point can be
      difficult and time-consuming.
    </para>
    <para>
      To avoid this, you can extract Test Cases from other Test Cases
      to combine them into reusable modules
      (<xref linkend="extracting-test-cases-from-editors-refactoring"/>).
    </para>
  </section>
  <section id="choosing-a-method">
    <title>Choosing a method</title>
    <para>
      Obviously, these two approaches lie on a continuum. You can
      ”mix-and-match” so that you can choose the approach that works
      best for you – a combination of the two or one method for one
      Test Case and the other for another Test Case.
    </para>
    <para>
      For example, if you know that a certain test procedure (e.g.
      logging in) has to be executed frequently, you can specify a
      Test Case to do this, and specfiy it to be easily reusable
      (using references as data-placeholders, and using general
      component names to be reassigned). For parts of the test which
      are not likely to be carried out more than once, you can specify
      them with data and definite component names.
    </para>
  </section>
</section>