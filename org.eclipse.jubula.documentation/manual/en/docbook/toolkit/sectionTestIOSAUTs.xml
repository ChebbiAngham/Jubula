<section id="iOSaut" version="5.0" xmlns="http://docbook.org/ns/docbook"
                                   xmlns:xi="http://www.w3.org/2001/XInclude"
                                   xmlns:xl="http://www.w3.org/1999/xlink" >
  <title>Testing iOS AUTs</title>
  <anchor role="helpid" id="autConfigSettingWizardPagePageContextId">Configuring an AUT</anchor>
  <anchor role="helpid" id="autConfigPropDialogContextId">Adding/editing AUT configurations</anchor>
  <para>
    You can write tests for iOS AUTs when you select the toolkit
    <emphasis>concrete</emphasis>, <emphasis>mobile</emphasis> or <emphasis>iOS</emphasis> in the
    Project properties.
  </para>
  <para>
    When you select <emphasis>iOS</emphasis> as the Project toolkit, the
    library Projects <emphasis>unbound_modules_concrete</emphasis>,
    <emphasis>unbound_modules_mobile</emphasis> and
    <emphasis>unbound_modules_iOS</emphasis> are automatically reused in your
    Project.
  </para>
  <para>
    The actions in the concrete library are described in the reference
    manual.
  </para>
  <section id="supported-ios-auts">
    <title>Supported iOS AUTs</title>
    <para>
      The following AUTs written for iOS are supported:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          You must be using iOS SDK 5.0 or higher. iOS AUTs on version
          7 of iOS are supported.
        </para>
      </listitem>
      <listitem>
        <para>
          You can run tests either on a simulator (i386) or on a real
          device (armv7 and armv7s).
        </para>
      </listitem>
    </itemizedlist>
  </section>
  <section id="setting-up-ios-aut">
    <title>Setting up an iOS AUT for testing</title>
    <para>
      If you want to test an <emphasis>iOS</emphasis> application, you
      have to prepare the AUT in order to make it testable.
    </para>
    <para>
      <para role="tip">This preparation is designed to be undertaken by a
      developer who has access to the AUT’s source code as well as
      knowledge of developing for iOS using Objective-C and Xcode.
      These instructions assume you are using Xcode 5. For other Xcode versions
      please adapt the instructions accordingly.</para>
    </para>
    <section id="create-a-testing-target">
      <title>Create a Testing Target</title>
      <para>
        We strongly recommend that you create a
        <emphasis role="strong">separate target</emphasis> which
        contains and uses all the necessary modifications for your AUT
        to be testable. Once you have created a second target for the
        testing-enabled version of your AUT to test, you can begin
        testing simply by running this second target. Having a
        separate target also ensures that no testing code will be
        released into the productive version of your app.
      </para>
      <para>
        The new target will start as a duplicate of your old target.
        To create the duplicated target:
      </para>
      <orderedlist>
        <listitem>
          <para>
            Select the project file for your app in the Project
            Navigator.
          </para>
        </listitem>
        <listitem>
          <para>
            In the project setting page, click on the black arrow icon
            <emphasis>”Show project and targets list”</emphasis> in the main content area
            in the very top left that hides/shows the project and tar-
            gets list. To duplicate your target select it and press
            <emphasis role="input">»COMMAND KEY+D«</emphasis>,
            or right+click the target and choose <emphasis>”Duplicate”</emphasis>
            entry of the context menu.
          </para>
        </listitem>
        <listitem>
          <para>
            The new target will be created. We suggest renaming it,
            e.g. to <emphasis><emphasis role="strong">GUI</emphasis><emphasis>dancer</emphasis> or Jubula Tests</emphasis>.
            by double-clicking the target in the list of project targets and changing the value
            to a new name.
          </para>
        </listitem>
        <listitem>
          <para>
            You can also (optionally) rename your <emphasis>iOS</emphasis>
            application to something more meaningful e.g. <emphasis>MyApp</emphasis>
            (<emphasis><emphasis role="strong">GUI</emphasis><emphasis>dancer</emphasis>
            or Jubula Tests</emphasis>) by selecting the <emphasis>”Build Settings”</emphasis>
            tab and searching for <emphasis>”Product Name”</emphasis>, then changing the value
            to a new name. After target name change the product name will also have this new
            name if you give the next name to <emphasis>”Product Name”</emphasis> in build settings:
          </para>
          <para>
            <emphasis role="input">${TARGET_NAME}</emphasis>
          </para>
          <para role="tip">
            Making the AUT testable can be achieved more easily
            and quickly by using a CocoaPods, however its usage is
            not obligatory. CocoaPods is a dependency manager for
            Objective-C, which automates and simpliﬁes the process
            of using 3rd-party libraries in your projects. You can ﬁnd
            more details about CocoaPods at<?linebreak?>
            <link xl:href="http://cocoapods.org">http://cocoapods.org</link>.
          </para>
          <para>
            Below, two ways to conﬁgure the Testing Target are described:
            with and without the CocoaPods usage.
          </para>
        </listitem>
      </orderedlist>
    </section>
    <section id="configure-the-testing-target-without-cocoapods">
      <title>Configure the Testing Target without CocoaPods</title>
      <para>
        Now that you have a target for your tests, add the tests to
        that target.
      </para>
      <orderedlist>
        <listitem>
          <para>
            The ﬁrst step is to link/add the <emphasis>librc.mobile.ios.nativ</emphasis>
            static library and <emphasis>UIRemoteControl.h</emphasis> ﬁle directly into
            your iOS application. Locate the <emphasis>development/iOS-support.zip</emphasis>
            ﬁle in the installation directory in Finder. Unzip it and drag all
            of its content into the Project Navigator. In the dialog to
            choose options for adding these ﬁles use <emphasis>”Add to target”</emphasis>
            option by checking a checkbox of the target you want to
            work with from the target list. This lets your project and
            thereby your <emphasis>iOS</emphasis> application be run as a testable AUT.
          </para>
        </listitem>
        <listitem>
          <para>
            With the project settings still selected in the Project
            Navigator, and the new integration tests target selected
            in the project settings, select the ”<emphasis>Build
            Phases</emphasis>” tab.
          </para>
        </listitem>
        <listitem>
          <para>
            Under the ”<emphasis>Link Binary With
            Libraries</emphasis>” section, press the
            ”<emphasis>+</emphasis>” button.
          </para>
        </listitem>
        <listitem>
          <para>
            In the sheet that appears, select
            <emphasis>CFNetwork.framework</emphasis> and
            <emphasis>SenTestingKit.framework</emphasis> and click
            ”<emphasis>Add</emphasis>”.
          </para>
        </listitem>
        <listitem>
          <para>
            Then click ”<emphasis>Add other...</emphasis>” in the
            lower left corner and locate and select the library
            <emphasis>librc.mobile.ios.nativ.a</emphasis> and click
            ”<emphasis>Open</emphasis>”.
          </para>
        </listitem>
        <listitem>
          <para>
            Next, make sure that the
            <emphasis>UIRemoteControl.h</emphasis> header file can be
            accessed. To do this, add the
            <emphasis>UIRemoteControl.h</emphasis> to the
            ”<emphasis>Header Search Paths</emphasis>” build setting.
            Start by selecting the ”<emphasis>Build
            Settings</emphasis>” tab of the project settings, and from
            there, use the filter control to find the
            ”<emphasis>Header Search Paths</emphasis>” setting.
          </para>
        </listitem>
        <listitem>
          <para>
            Double click the value, and add the file
            <emphasis>UIRemoteControl.h</emphasis> to the list. If
            it’s not there already, you should add the $(inherited)
            entry as the first entry in this list.
          </para>
        </listitem>
        <listitem>
          <para>
            The iOS support takes advantage of Objective C’s ability
            to add categories to an object, but this isn’t enabled for
            static libraries by default. To enable this, add the -ObjC
            and -all_load flags to the ”<emphasis>Other Linker
            Flags</emphasis>” build settings.
          </para>
        </listitem>
        <listitem>
          <para>
            If you build for iOS Simulator, but linking against
            dylib built, build error with linker command failed
            might occur. To avoid this, add to the <emphasis>”Framework
            Search Paths”</emphasis> build setting the line
            <emphasis>”$(SDKROOT)/Developer/Library/Frameworks”</emphasis> right after
            the $(inherited) entry.
          </para>
        </listitem>
        <listitem>
          <para>
            Finally, add a preprocessor flag to the testing target so
            that you can conditionally include code. This will help to
            make sure that none of the testing code makes it into the
            production app. Call the flag
            <emphasis role="input">RUN_FUNCTIONAL_TESTS</emphasis> and add it under
            the ”<emphasis>Preprocessor Macros</emphasis>”. Again,
            make sure the $(inherited) entry is first in the list.
          </para>
        </listitem>
      </orderedlist>
    </section>
    <section id="configure-the-testing-target-with-cocoapods">
      <title>Configure the Testing Target</title>
      <para role="warning">
        You need to have CocoaPods installed on your machine
        before you start making your AUT testable with its help.
      </para>
      <para>
        To conﬁgure the Testing Target with CocoaPods, you need a
        speciﬁcation - <emphasis>.podspec</emphasis> ﬁle. It describes a version of
        the <emphasis>Pod</emphasis> library and includes details about where the
        source should be fetched from, what ﬁles to use, the build settings to apply,
        and other general metadata such as its name, version, and
        description. We provide two types of such ﬁles. The <emphasis>rcmobile.podspec</emphasis>
        ﬁle will add a static library, while the <emphasis>rcmobile-debug.podspec</emphasis>
        ﬁle will import all source ﬁles to the project dynamically, which allows you
        to change code for testing and to debug more deeply.
      </para>
      <orderedlist>
        <listitem>
          <para>
            In the installation directory you will ﬁnd a development
            folder and an <emphasis>iOS-support</emphasis> zip archive inside it which you
            have to unzip. There you will see a <emphasis>rcmobile.podspec</emphasis>.
            <emphasis>rcmobile-debug.podspec</emphasis> is located in a 
            <emphasis>”development/git/com.bredexsw.jubula.core/com.bredexsw.jubula.rc.mobile.ios.nativ”</emphasis>
            folder of the installation directory.
          </para>
        </listitem>
        <listitem>
          <para>
            In a directory of your AUT XCode project location create a
            <emphasis>Podﬁle</emphasis> by running this command in a terminal:
            
            <para>
              <emphasis role="input">$ pod init</emphasis>
            </para>
          </para>
        </listitem>
        <listitem>
          <para>
            Open the newly created <emphasis>Podﬁle</emphasis> and add
            <emphasis>”rcmobile”</emphasis> static library (as a local source)
            or dynamically linked source ﬁles with help of
            <emphasis>”rcmobile-debug”</emphasis> by entering the following line
            inside the <emphasis>”do ... end”</emphasis> block for each target you
            want to make testable:
            
<programlisting>
target "TargetName" do
pod ’rcmobile’, :path => ’iOS-support-path’
end

or

target "TargetName" do
pod ’rcmobile-debug’, :path => ’sources-path’
end
</programlisting>
            
            <emphasis>”iOS-support-path”</emphasis> is the path where
            <emphasis>rcmobile.podspec</emphasis> ﬁle is located.
            <emphasis>”sources-path”</emphasis> is the path where
            <emphasis>rcmobile-debug.podspec</emphasis> ﬁle and folder
            with sources are located. By default both of them are located in the
            <emphasis>”development/git/com.bredexsw.jubula.core/com.bredexsw.jubula.rc.mobile.ios.nativ”</emphasis>
            folder of the installation directory. Other Podﬁle content
            may remain as it is.
          </para>
        </listitem>
        <listitem>
          <para>
            Install the <emphasis>Podﬁle</emphasis> to add the library to the AUT by running
            this command in the terminal:
            
            <para>
              <emphasis role="input">$ pod install</emphasis>
            </para>
          </para>
          <para role="warning">
            You must use the <emphasis role="input">»’«</emphasis> (apostrophe) symbol
            around the library name and the path in the <emphasis>Podﬁle</emphasis> to install it,
            otherwise you will receive the error "Invalid ’Podﬁle’ ﬁle".
          </para>
        </listitem>
        <listitem>
          <para>
            From now on the <emphasis>project-name.xcworkspace</emphasis> ﬁle must be
            used instead of the project ﬁle.
          </para>
        </listitem>
        <listitem>
          <para>
            If you have used the <emphasis>rcmobile.podspec</emphasis>, the static library
            is now added to the project. If you used the <emphasis>rcmobile-debug.podspec</emphasis>
            ﬁle all source ﬁles are dynamically linked to the project through the alias and you can
            ﬁnd them under the <emphasis>Development Pods library</emphasis> in the XCode workspace of
            your project.
          </para>
        </listitem>
      </orderedlist>
    </section>
    <section id="add-hook-into-the-aut">
      <title>Add hook into the AUT</title>
      <para>
        Finally, the app needs a hook so that it actually allows the
        attachment and running of the tests when executing the Tests
        target. This is achieved by using the
        <emphasis>RUN_FUNCTIONAL_TESTS</emphasis> macro that was
        defined in the preceding section. This ”<emphasis>preprocessor
        macro</emphasis>” is only defined in the testing target, so
        the remote controlling won’t be possible in the regular
        target. To allow your AUT to be remote controlled, add the
        following code to your application delegate:
      </para>
<programlisting>
...
#if RUN_FUNCTIONAL_TESTS
#import &quot;UIRemoteControl.h&quot;
#endif
...
</programlisting>
      <para>
        and the following code to the end of its -
        (void)applicationDidFinishLaunching[withOptions]: method
      </para>
<programlisting>
...
#if RUN_FUNCTIONAL_TESTS
    [UIRemoteControl attach];
    // alternatively you can
    // allow the UIRemoteControl 
    // to use a specific port number 
    // on the iOS device 
    // by using:
    // 
    // [UIRemoteControl attach:&lt;portNo&gt;];
    // 
    // this is necessary
    // e.g. when you're running 
    // different AUTs in parallel on 
    // the same iOS device
#endif
...
</programlisting>
      <para>
        Everything should now be configured. When you run the AUT
        tests target it will launch your app and allow the ITE to
        remotely attach (on the port specified, or on 11022 if none is
        entered) and execute tests.
      </para>
      <para>
        <para role="warning">If you do not follow the above steps, the AUT Agent
        will not be able to communicate with your AUT!</para>
      </para>
      <para>
        This documentation is derived from the KIF installation
        documentation (http://github.com/square/KIF) as we make use of
        KIF internally.
      </para>
    </section>
  </section>
  <section id="design-for-testability-ios-auts">
    <title>Design for testability in iOS AUTs</title>
    <section id="naming-components-3">
      <title>Naming components</title>
      <para>
        To be able to robustly test iOS AUTs, we highly recommend
        naming the components in your AUT. The name that is used as a
        part of the object recognition is the <emphasis>accessibility
        identifier</emphasis>. This is a variable that can be
        specified for each UI component in an iOS AUT. It is
        language-independent and is designed for use in automated
        tests. We recommend using unique names throughout the AUT.
      </para>
    </section>
    <section id="adding-support-for-text-retrieval-2">
      <title>Adding support for text retrieval</title>
      <para>
        If you use custom UI views and cannot access the text
        contained in them during a test, then you can implement the
        UITestable protocol, which provides a method allowing the
        remote control to read the text from such controls.
      </para>
    </section>
  </section>
  <section id="addressing-correct-component-ios">
    <title>Addressing the correct component in your iOS tests</title>
    <para>
      One of the specifics of iOS AUTs is that individual components
      such as labels on buttons are separately collectible. You can
      specify tests that will tap e.g. the label on a button, but this
      may not necessarily result in the button itself being tapped. In
      order to tap the button, it may be necessary to ensure that the
      action you perform is actually sent to the button, and not the
      label.
    </para>
    <para>
      Another example of this is when dealing with components such as
      lists and tabbed controls. You can map the individual items
      within the list or the tabbed control in order to check them or
      tap them, but it is also possible to map the whole tabbed
      control or list in order to address the items within the
      component based on their content or index. Depending on what you
      want to test, you may want one option or the other. As a general
      rule, aiming to address the higher-level component (the list
      instead of the button, for example), is usually preferable.
    </para>
    <para>
      The different types of object mapping gestures (see
      <xref linkend="object-mapping-ios"/>) ensure that you can always see which
      components are available. Part of your test design will involve
      identifying the component you want to test and choosing the
      correct technical name to map to your component name.
    </para>
  </section>
  <section id="working-with-ios-components-and-actions">
    <title>Working with iOS components and actions</title>
    <para>
      When testing iOS AUTs, many of the components will be similar to
      those found in desktop AUTs. You can use the actions from the
      <emphasis>unbound_modules_concrete</emphasis> library to perform
      actions such as:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Click (tap) items.
        </para>
      </listitem>
      <listitem>
        <para>
          Check existence and various properties of components.
        </para>
      </listitem>
      <listitem>
        <para>
          Synchronize based on component availability.
        </para>
      </listitem>
      <listitem>
        <para>
          Replace text on text components.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      The following sections deal with how to use actions to address
      specific components in iOS.
    </para>
    <section id="working-with-ios-switches">
      <title>Working with iOS switches</title>
      <para>
        Switches in iOS AUTs (<xref linkend="Switch"/>) can be addressed using
        the actions:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Click (to tap the switch). Depending on the AUT, this will
            toggle the state of the switch.
          </para>
        </listitem>
        <listitem>
          <para>
            Other actions on the <emphasis>Graphics
            Component</emphasis> such as check existence, wait for
            component etc.
          </para>
        </listitem>
        <listitem>
          <para>
            Swipe. By entering a direction, you can specify whether to
            activate or deactivate the switch.
          </para>
        </listitem>
        <listitem>
          <para>
            Check selection (Button Component) - use this to check
            whether the switch is activated or not.
          </para>
        </listitem>
      </itemizedlist>
      <figure id="Switch">
        <title>Switch</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/Switch.png"/>
          </imageobject>
          <textobject><phrase>Switch</phrase></textobject>
        </mediaobject>
      </figure>
    </section>
    <section id="working-with-ios-table-views-lists">
      <title>Working with iOS Table Views (lists)</title>
      <itemizedlist>
        <listitem>
          <para>
            <emphasis>Table Views</emphasis> in iOS are used to
            organize information on the screen. They may just consist
            of items (and therefore look like a simple list
            (<xref linkend="TableViewSimple"/>)), or they may contain various
            sections – each section can contain other components
            (<xref linkend="TableViewGrouped"/>).
          </para>
        </listitem>
        <listitem>
          <para>
            Both types of <emphasis>Table View</emphasis> are testable
            using the actions available on the
            <emphasis>List</emphasis> component.
          </para>
        </listitem>
        <listitem>
          <para>
            You can, e.g. select items from the list, check their
            existence etc.
          </para>
        </listitem>
        <listitem>
          <para>
            In the <emphasis>Table Views</emphasis> that contain other
            components, you can also address the individual components
            (labels, buttons etc.) in the list using the actions such
            as check existence, check text, click etc.
          </para>
        </listitem>
        <listitem>
          <para>
            When writing a test on these components, it is important
            to decide which component you want to test
            (<xref linkend="addressing-correct-component-ios"/>).
          </para>
        </listitem>
        <listitem>
          <para>
            If you need to scroll to a certain section of a list that
            is currently not visible, you can use the
            <emphasis>select</emphasis> action on the
            <emphasis>list</emphasis> component to make the correct
            portion of the screen visible. You can also use 0 clicks
            to simply hover over the item instead of tapping it.
            <para role="tip">Bear in mind that many apps remember where you were
            on a screen. You may need to add explicit scrolling (via
            selection) to your tests in order to ensure that the
            components you require are on screen.</para>
          </para>
        </listitem>
      </itemizedlist>
      <figure id="TableViewSimple">
        <title>Simple Table View (list component)</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/TableViewSimple.png"/>
          </imageobject>
          <textobject><phrase>Simple Table View (list
          component)</phrase></textobject>
        </mediaobject>
      </figure>
      <figure id="TableViewGrouped">
        <title>Grouped Table View (list component)</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/TableViewGrouped.png"/>
          </imageobject>
          <textobject><phrase>Grouped Table View (list
          component)</phrase></textobject>
        </mediaobject>
      </figure>
    </section>
    <section id="working-with-ios-tabbed-controls">
      <title>Working with iOS tabbed controls</title>
      <itemizedlist>
        <listitem>
          <para>
            Many components in iOS AUTs can be addressed as
            <emphasis>tabbed controls</emphasis> – in a similar way to
            tabbed panes in a Swing AUT for example.
          </para>
        </listitem>
        <listitem>
          <para>
            The components <emphasis>tabbed bar</emphasis> and
            <emphasis>segmented control</emphasis>
            (<xref linkend="SegmentedControls"/>) are examples of two
            components that can be addressed with the actions on the
            <emphasis>tabbed control component</emphasis>. You can
            select a tab based on its content or its index, check the
            selection of a specific tab, check the existence etc.
          </para>
        </listitem>
        <listitem>
          <para>
            In many cases, you will also be able to map the individual
            tabs as e.g. buttons or labels. As described earlier
            (<xref linkend="addressing-correct-component-ios"/>), we highly recommend
            ensuring that you are addressing the most relevant and
            high-level control for your test.
          </para>
        </listitem>
      </itemizedlist>
      <figure id="SegmentedControls">
        <title>Segmented controls (tabbed controls)</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/SegmentedControls.png"/>
          </imageobject>
          <textobject><phrase>Segmented controls (tabbed
          controls)</phrase></textobject>
        </mediaobject>
      </figure>
    </section>
    <section id="working-with-ios-pickers">
      <title>Working with iOS pickers</title>
      <itemizedlist>
        <listitem>
          <para>
            The iOS components <emphasis>pickers</emphasis> can be
            addressed using actions for combo components.
          </para>
        </listitem>
        <listitem>
          <para>
            You can select items from pickers that have only one
            column (<xref linkend="SinglePicker"/>) using the actions for
            <emphasis>combo component</emphasis> in the concrete
            toolkit. You can also check the existence of items in the
            picker, check their selection etc.
          </para>
        </listitem>
        <listitem>
          <para>
            To work with pickers that have multiple columns, you
            should use the actions in the iOS toolkit to select from
            the picker based on the column value. In this way, you can
            specify which column the selection should take place in.
          </para>
        </listitem>
      </itemizedlist>
      <figure id="SinglePicker">
        <title>Single picker (combo component)</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/SinglePicker.png"/>
          </imageobject>
          <textobject><phrase>Single picker (combo
          component)</phrase></textobject>
        </mediaobject>
      </figure>
      <figure>
        <title>Picker with multiple columns</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/MultiPicker.png"/>
          </imageobject>
          <textobject><phrase>Picker with multiple
          columns</phrase></textobject>
        </mediaobject>
      </figure>
      <para>
        <emphasis role="strong">Hints for working with pickers</emphasis>
      </para>
      <variablelist>
        <varlistentry>
          <term>
            Check text on multi-column pickers:
          </term>
          <listitem>
            <para>
              If you use the action <emphasis>check text</emphasis> on
              pickers with multiple columns, the result will be a
              concatenated value of all columns.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            Grey items not addressable:
          </term>
          <listitem>
            <para>
              Items that are grey in the picker cannot be checked or
              selected.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            Index-based selection on infinite pickers:
          </term>
          <listitem>
            <para>
              Some pickers do not have a finite amount of items – they
              scroll infinitely. We strongly advise against usin
              index-based selection or checking on such pickers.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="working-with-gestures">
      <title>Working with gestures</title>
      <itemizedlist>
        <listitem>
          <para>
            In the iOS toolkit, you will find swipe actions for many
            components. You can use these actions to perform swipes in
            a specific direction.
          </para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="ToolkitiOSKeyboard">
      <title>Working with the keyboard</title>
      <itemizedlist>
        <listitem>
          <para>
            To use actions such as <emphasis>replace text</emphasis>,
            you do not need to worry about using the keyboard – the
            test execution component does this for you.
          </para>
        </listitem>
        <listitem>
          <para>
            However, if you would like to press specific buttons on
            the keyboard such as <emphasis role="input">»DONE«</emphasis>,
            <emphasis role="input">»DELETE«</emphasis> and so on, then you
            should use the action in the
            <emphasis>unbound_modules_ios</emphasis> called
            <emphasis>Tap View with Accessibility Label</emphasis>.
          </para>
        </listitem>
        <listitem>
          <para>
            This allows you to press any item on the screen (on the
            keyboard or elsewhere) based on its accessibility label:
          </para>
          <itemizedlist>
            <listitem>
              <para>
                The accessibility label is an internal attribute for a
                component that is designed to be used by screen
                readers etc.
              </para>
            </listitem>
            <listitem>
              <para>
                You can find out the accessibility label for an item
                by using the Accessibility Inspector on e.g. an iOS
                simulator. You can activate the Inspector via the
                General Settings.
              </para>
            </listitem>
            <listitem>
              <para>
                Once you know the label, you can enter it as a
                parameter (exactly as it is written).
              </para>
            </listitem>
            <listitem>
              <para>
                Bear in mind that accessibility labels are
                language-dependent (i.e. you will need to translate
                the test data), and also sometimes
                orientation-dependent. It is also not necessarily the
                case that the accessibility label is the same as the
                text on the item that is visible in the AUT.
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
      <para>
        <para role="tip">Many iOS devices have a setting activated to start each
        text with a capital letter. We recommend deactivating this
        setting for your tests, as attempts to enter lowercase text at
        the beginning of a textfield will otherwise fail.</para>
      </para>
    </section>
    <section id="working-with-unmappable-unsupported-components">
      <title>Working with unmappable (unsupported) components</title>
      <para>
        If there is a component that is unsupported, then you may be
        able to tap it using the action in the
        <emphasis>unbound_modules_ios</emphasis> called <emphasis>Tap
        View with Accessibility Label</emphasis>. For more information
        on this action, see the section on working with the keyboard
        (<xref linkend="ToolkitiOSKeyboard"/>).
      </para>
    </section>
    <section id="other-important-information-for-testing-ios-auts">
      <title>Other important information for testing iOS AUTs</title>
      <para>
        <emphasis role="strong">Non-supported components</emphasis><?linebreak?>
        The following components are not a part of the iOS toolkit, and their actions from the concrete toolkit cannot be used in iOS tests:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Menus
          </para>
        </listitem>
        <listitem>
          <para>
            Tables
          </para>
        </listitem>
        <listitem>
          <para>
            Trees
          </para>
        </listitem>
        <listitem>
          <para>
            Context menus
          </para>
        </listitem>
      </itemizedlist>
      <para>
        <emphasis role="strong">Non-supported actions</emphasis><?linebreak?>
        The following actions are currently not supported:
      </para>
      <variablelist>
        <varlistentry>
          <term>
            Take screenshot:
          </term>
          <listitem>
            <para>
              It is currently not possible to take screenshots as a
              part of the test. Automatic screenshots on errors are,
              however, produced.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            Restart:
          </term>
          <listitem>
            <para>
              The restart action restarts the internal connection to
              the AUT, not the AUT itself. This means that you should
              consider how to reset your AUT to a known starting point
              as part of your Event Handlers (to ensure that the test
              can continue despite an error). How to do this will be
              dependent on your AUT.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            Check text on secure textfields:
          </term>
          <listitem>
            <para>
              The text on a secure textfield cannot be accessed, e.g.
              to perform check text.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            Check / store property
          </term>
          <listitem>
            <para>
               actions are not supported in the current version.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            Application input text
          </term>
          <listitem>
            <para>
               is not supported. Use input text or replace text on
              <emphasis>Component with Text Input</emphasis> instead.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            Copy to clipboard
          </term>
          <listitem>
            <para>
               is currently not supported.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
        <emphasis role="strong">Other information</emphasis>
      </para>
      <variablelist>
        <varlistentry>
          <term>
            No detailed information on test failure:
          </term>
          <listitem>
            <para>
              When a Test Step fails, there is currently no detailed
              information about the reason for the error.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            Support characters for text input:
          </term>
          <listitem>
            <para>
              Any keys on the keyboard that are only accessible by a
              long press, and not by switching the whole keyboard
              (e.g. characters with umlauts) cannot currently be
              entered.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            Long taps and continuous gestures:
          </term>
          <listitem>
            <para>
              cannot currently be carried out.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            Disabled components
          </term>
          <listitem>
            <para>
               cannot be mapped directly using e.g. tap. Instead, to
              collect the technical name for a disabled component, you
              should use the <emphasis>long tap</emphasis> gesture to
              collect all of the visible components. This includes the
              disabled components. 
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>
  <section id="testing-auts-written-with-monotouch">
    <title>Testing AUTs written with Monotouch</title>
    <section id="create-a-binding-project">
      <title>Create a binding project</title>
      <para>
        First you have to create a MonoTouch Binding Project. The
        project template can be found in the category
        <emphasis>C#/MonoTouch</emphasis>. A binding project contains
        a reference to the MonoTouch library as well as two C# files
        called <emphasis>ApiDefinition.cs</emphasis> and
        <emphasis>StructsAndEnums.cs</emphasis>.
      </para>
    </section>
    <section id="add-the-library-to-the-binding-project">
      <title>Add the library to the binding project</title>
      <para>
        Add the library file librc.mobile.ios.nativ.a to the new
        binding project. The file is part of the archive
        <emphasis>development/iOS-support.zip</emphasis> in the
        installation directory.
      </para>
      <para>
        MonoDevelop will ask either to copy, move or link the file in
        the binding project. We recommend choosing copy because
        MonoDevelop will place a generated C# file called
        <emphasis>librc.mobile.ios.nativ.linkwith.cs</emphasis> next
        to the library file.
      </para>
    </section>
    <section id="setting-up-linker-options">
      <title>Setting up linker options</title>
      <para>
        The file <emphasis>librc.mobile.ios.nativ.linkwith.cs</emphasis> specifies the linker options. It contains a single annotation named <emphasis>LinkWith</emphasis>. Change the annotation to:
      </para>
<programlisting>
[assembly: LinkWith 
(&quot;librc.mobile.ios.nativ.a&quot;, 
LinkTarget.Simulator | LinkTarget.ArmV6 
| LinkTarget.ArmV7,
 &quot;-ObjC -all_load&quot;, ForceLoad = true, 
Frameworks=&quot;CFNetwork&quot;)
</programlisting>
      <para>
        Doing this allows your AUT to be tested on the simulator as
        well as on iOS devices. The framework
        <emphasis>CFNetwork</emphasis> is needed to communicate with
        the ITE.
      </para>
    </section>
    <section id="defining-the-api-contract">
      <title>Defining the API contract</title>
      <para>
        An Objective-C header file is provided. To use the library
        from within a .NET project, you have to link the library’s
        interface parts to .NET structures.
      </para>
      <para>
        Linking is done in the file
        <emphasis>ApiDefinition.cs</emphasis>. You have to translate
        the header file contents into some C# interfaces. Finally you
        have to annotate the interfaces/methods/parameters that name
        the library’s objects.
      </para>
      <para>
        Detailed information about translation and annotation may be
        found on Xamarins web site:
        <link xl:href="http://docs.xamarin.com/ios/Guides/Advanced_Topics/Binding_Objective-C_Libraries">http://docs.xamarin.com/ios/Guides/Advanced_Topics/Binding_Objective-C_Libraries</link>.
      </para>
      <para>
        To use the library, adapt the following:
      </para>
      <para>
        <informaltable>
          <tgroup cols="2">
            <colspec align="left"/>
            <colspec align="left"/>
            <thead>
              <row>
                <entry>Library's header file content</entry>
                <entry>Linking in ApiDefinition.cs</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  @interface ObjCClass<?linebreak?>
                  ...
                </entry>
                <entry>
                  [BaseType (typeof (NSObject))]<?linebreak?>
                  interface ObjCClass {
                </entry>
              </row>
              <row>
                <entry>
                  @end
                </entry>
                <entry>
                  ...<?linebreak?>
                  }
                </entry>
              </row>
              <row>
                <entry>
                  +(void)method1:(int)parameter;
                </entry>
                <entry>
                  [Static, Export("method1:")]<?linebreak?>
                  void method1(int parameter);
                </entry>
              </row>
              <row>
                <entry>
                  -(NSString*)method2;
                </entry>
                <entry>
                  [Export("method2")]<?linebreak?>
                  NSString method2();
                </entry>
              </row>
              <row>
                <entry>
                  @protocol MyDelegate<?linebreak?>
                  -(int)method3;<?linebreak?>
                  @end
                </entry>
                <entry>
                  [BaseType (typeof(NSObject))]<?linebreak?>
                  [Model]<?linebreak?>
                  interface MyDelegate {<?linebreak?>
                  [Export("method3")]<?linebreak?>
                  [Abstract]<?linebreak?>
                  int method3();<?linebreak?>
                  }
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </para>
    </section>
    <section id="building-a-.net-library">
      <title>Building a .NET library</title>
      <para>
        When linking is done, build the binding project in Release
        mode. When it is done, you will find a DLL in the bin/Release
        directory of the binding project.
      </para>
      <para>
        Copy this DLL to your project for your AUT and add it as a
        reference to a .NET Assembly.
      </para>
      <para>
        When the library changes, we recommend to remove this
        reference and repeat the entire process.
      </para>
    </section>
    <section id="add-hook-into-aut">
      <title>Add hook into AUT</title>
      <para>
        When the binding DLL is referenced by your project, you can
        use the namespace and all interfaces defined in
        <emphasis>ApiDefinition.cs</emphasis>. Adding the hook is the
        same as described for native iOS Apps but using C# syntax. You
        should omit the preprocessor macros mentioned there or
        implement your own switch for enabling the test hook.
      </para>
      <para>
        Native iOS Apps are required to provide a ”window” property in
        the AppDelegate. Your C# AppDelegate has to provide and use
        this property too:
      </para>
<programlisting>
[Export(&quot;window&quot;)]
UIWindow window { get; set; }
</programlisting>
    </section>
  </section>
</section>