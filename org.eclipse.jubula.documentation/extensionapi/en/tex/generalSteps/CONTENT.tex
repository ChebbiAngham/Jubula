\chapter{Introduction}
\label{introduction}

\app{} starts, controls, and observes \gdauts using its remote control component. In
order for the \gdagent to know how to control each element of a GUI, we have
outfitted the \gdagent with a pluggable interface for graphic components. An
adapter factory containing one or more components must be implemented for and
deployed with the \gdaut. On the client site each GUI toolkit that \app{}
supports is described in a toolkit plug-in.

We have opened up an interface to our users to allow great and flexible
customizations. You can extend existing functionality, or provide support for
in-house graphic components by implementing your own so-called
\textbf{\gdtesterclasses.}

This handbook shows general steps for creating \app{} toolkit extensions, which
is described in chapter \ref{toolkitExtension}. In this chapter you will find
also an example and some hints for a migrating to the new API. Last but not
least chapter \ref{functions} describes how to create a custom \app{} function,
which can be used in \app{} tests.

\chapter{Creating \app{} toolkit extensions}
\label{toolkitExtension}

The following chapter describes the general steps to take for creating a \app{}
toolkit extensions with custom defined components and actions. This chapter
begins with listing the requirements followed by showing the necessary steps
for creating the \app{} client and remote control extension. The extension for
the \app{} client is described in section \ref{clientExtension} and the
implementation for the \app{} remote control extension in section
\ref{serverExtension}.

Extension examples with source code can be found in the sub directory\\
\bxshell{examples/development/extension/src/}\\
of a \app{} installation.

In general you always have to extend two parts of \app{}:
\begin{itemize}
\item The \app{} client by writing your own \textbf{toolkit} plug-in:\\
      This will tell the client, which new components and actions are available.
\item The \app{} remote control by writing your own \textbf{fragment}:\\
      This part actually performs the actions on the new components.
\end{itemize}

In this chapter normally all used directory names are located in the
installation directory of \app{} as long as nothing else is specified.

\section{Requirements}
To create your own \app{} extension, you need:
\begin{itemize}
\item \app{} 2.0 or later
\item Eclipse 3.4 or later (4.2 recommanded)
\item JDK 5.0
\item Write access in the following directories:\\
\bxshell{\MakeLowercase{\app{}}/plugins/}\\
\bxshell{server/plugins/}
\end{itemize}

\section{\app{} client extension}
\label{clientExtension}

This section shows how to develop the \app{} client extension. We describe the
steps to create the toolkit plug-in and how it can be exported into \app{}.

\subsection{Creating the toolkit plug-in for \app{}}

The following steps have to be done to extend the \app{} client:
\begin{enumerate}
 \item Create a \textbf{Plug-in Project} for your toolkit project.
 \item Create a \textbf{Feature Project} referencing your toolkit project from
 the previous step.
 \item Set the features
       \begin{itemize}
        \item \bxname{org.exclipse.rcp} and
        \item \bxname{org.exclipse.jubula.feature}
       \end{itemize}
       from the \app{} installation folder \bxshell{\MakeLowercase{\app{}}/} as
       your \textbf{Target Platform} in the workspace preferences.
 \item Add the following dependencies to your toolkit project:
       \begin{itemize}
        \item \bxname{org.eclipse.jubula.tools} and
        \item \bxname{org.eclipse.jubula.toolkit.common}
       \end{itemize}
 \item Use and configure the following extension point in your toolkit
       project:\\
       \bxname{org.eclipse.jubula.toolkit.common.toolkitsupport}.
 \item Implement the interface \bxshell{ITookitProvider} from the extension
 point of the previous step.
 \item Create the definition of your own toolkit in the file\\
       \bxshell{ComponentExtension.xml} by choosing one or more of the following
       possibilities:
       \begin{itemize}
        \item Extend existing \app{} components with new actions,
        \item derive new components from existing \app{} components, or
        \item define a new component.
       \end{itemize}
 \item Manage the i18n keys in the properties file.
\end{enumerate}

You will find projects in zip-files as a showcase for steps 1-8, which are
located in the directory\\
\bxshell{examples/development/extension/src}.\\
Each zip-file contains an example for a specific toolkit, e.g. a Swing example
extends the \bxshell{JSlider} component.

These example projects can be simply imported into your Eclipse workspace. Set
the target after importing the projects as described in step 3. All other steps
have already be done in the examples.

\subsection{Deploying the toolkit plug-in in \app{}}

After creating the toolkit feature, we describe the steps to take for deploying
it in the \app{} client. At first we export the toolkit feature to an update
site and then we use the update site to install the feature into \app{}.
 
\subsubsection{Create an update site for the toolkit feature}

\begin{enumerate}
\item Create an \textbf{Update Site Project}.
\item Add a category to your update site with defining its \bxname{ID} and
      \bxname{Name}.
\item Add your toolkit feature to the category created in the previous step.
\item Build the created toolkit update site. The directory of the toolkit
      update site project serves as an update site, which is later used to
      install your toolkit feature into \app{}. Remember to build and then
      synchronize this update site, if you have changed the toolkit feature.
\end{enumerate}

\subsubsection{Install the toolkit feature from the update site}

\begin{enumerate}
\item Start \app{} and select from the main menu\\
\bxmenu{Help}{Install new software...}{}.
\item Click the \bxmenu{Add...}{}{}
button in the \bxname{Install} dialog that appears.
\item Click the \bxmenu{Local...}{}{} button in the \bxname{Add Repository} dialog
that appears
\item Navigate to the directory, that contains your update site and confirm your
selection.
\item Click \bxmenu{OK}{}{} to exit the \bxname{Add Repository} dialog.
 The active dialog should now be \bxname{Install}.
\item Ensure that the check box named \bxname{Group items by category} is
deselected. Your feature should be visible in the central table of the dialog.
\item Ensure that the check box next to your feature is selected and click
 \bxmenu{Next}{}{}.
\item Confirm the \bxname{Installation Details} by clicking the \bxmenu{Next}{}{}
 button again.
\item Accept the license agreement terms and click \bxmenu{Finish}{}{}.
\item A warning dialog may appear to warn you installing unsigned content.
 Click \bxmenu{OK}{}{} in this dialog, if the feature comes from a trusted
 source. This should be the case as long as you install your own feature.
 Then the installation process begins.
\item Click the \bxmenu{Restart Now}{}{} button to perform a restart of \app{},
 when a dialog appears, which suggests restarting \app{} in order to safely
 finish the update / installation.  After the restart your \app{} extension
 feature is installed.
\end{enumerate}

\section{\app{} remote control extension}
\label{serverExtension}

\gdauts{} are controlled by the remote control called \gdagent. The \app{}
client is also executing the \app{} remote control, if the embedded agent is
used. Apart from that, the normal AUT agent runs as a remote control in a
separate process independently from the \app{} client.
For each supported component known to \app{} a \gdtesterclass must exist.
This class implements the test actions, that can be carried out on the component.
You need to write a fragment for your component, which contains the
\gdtesterclass and a corresponding adapter factory.

\subsection{Creating the fragment}

The following steps have to be done to extend the \app{} remote control:

\begin{enumerate}
  \item Install the zip-file\\
        \bxshell{development/extension-toolkit-rc.zip}\\
        as an update site. Verify, that the check box \textbf{Include required
        software} is not checked, while adding the update site. This includes
        the target and the Java documention of the source code.
  \item Set the installed update site as your target platform.
  \item Create a fragment project with one of the following bundles as host:
    \begin{itemize}
      \item \bxshell{org.eclipse.jubula.rc.swing}\\
            for extending Swing support.
      \item \bxshell{org.eclipse.jubula.rc.swt}\\
            for extending SWT support without RCP environment.
      \item \bxshell{org.eclipse.jubula.rc.rcp.swt}\\
            for extending SWT support in Eclipse 3.x and 4.x (including compat
            layer).
      \item \bxshell{org.eclipse.jubula.rc.rcp.e3.swt}\\
            for extending GEF support in Eclipse 3.x (without compat
            layer).
   \end{itemize}
  \item Write your own adapter and \gdtesterclasses.
\end{enumerate}

Adapters are used for all supported toolkits, i. e. Swing, SWT, GEF and RCP.
They wrap and specify graphic components in a form we need for our
\gdtesterclasses. You can write your own adapter or reuse our existing
adaptors. We recommend reusing our adapters to take advantage of the already
existing code.

Before we have a look at the \app{} remote control examples in section
\ref{remoteControlExamples}, we describe in general, how to create an
adapter and \gdtesterclasses.

\subsubsection{Creating an adapter}

For using an adapter you have to implement the interface
\bxshell{IAdapterFactory}, which is defined in the package named\\
\bxname{org.eclipse.jubula.rc.common.adaptable}.\\
It is necessary, that the implementation of this interface resists in a package
named\\
\bxname{org.eclipse.jubula.rc.common.adapter}.\\
The package naming is important for the \app{} remote control, because adapters
can only be found, if they are located in a package with the mentioned name.

In order to support your own components, the targeted type must be an instance
of \bxshell{IComponent}, which is defined in the package named\\
\bxname{org.eclipse.jubula.rc.common.tester.adapter.interfaces}.\\
This targeted type can be used for text components. If you want to support your
own graphical component, you should at least use the interface
\bxshell{IWidgetComponent} as the targeted type, which is a child of
\bxshell{IComponent}. Both interfaces are defined in the same package.

For Swing and SWT there are also specific implementations of different
adapters in the following packages, which can be used for your own component:\\
\bxname{org.eclipse.jubula.rc.swing.tester.adapter}\\
\bxname{org.eclipse.jubula.rc.swt.tester.adapter}

Now we know, how to create an own adapter in general. The next step is to
implement one or more \gdtesterclass. 

\subsubsection{Creating a \gdtesterclass}

The functionally important aspect of a \gdtesterclass is, that it
contains public methods for the \app{} test actions, which will appear in
the client. These methods are linked to testable actions within a user-defined
\app{} client plug-in. Each \app{} client extension provides an XML
configuration file, which defines the available methods with parameters, as
well as information for string externalization.

You can write your own \gdtesterclasses, but if you only want to support a new
component with existing actions, you could use one of our existing
\gdtesterclasses, which you can find in the package named\\
\bxname{org.eclipse.jubula.rc.common.tester}. For Swing and SWT there are also
specific implementations in the following packages:\\
\bxname{org.eclipse.jubula.rc.swing.tester}\\
\bxname{org.eclipse.jubula.rc.swt.tester}

Please take the following guidelines into consideration for creating
\gdtesterclasses:
\begin{itemize}
  \item The class must be compatible with \bxname{Java 1.4}.
  \item It must either implement
  \begin{itemize}
    \item the interface \bxshell{ITester} defined in the package named\\
        \bxname{org.eclipse.jubula.rc.common.tester.interfaces},\\
	 \item or the abstract class \bxshell{AbsstractUITester}
	     defined in the package named\\
	     \bxname{org.eclipse.jubula.rc.common.tester}.
  \end{itemize}
  \item The component must provide \textbf{public} methods for all actions
        declared by the XML configuration file of the corresponding \app{}
        client extension.
  \item Each method, that implements an action, must throw a\\
        \bxshell{StepExecutionException}\\
        defined in the package named\\
        \bxname{org.eclipse.jubula.rc.common.exception}
        to notify \app{}, if executing of the action has been failed.
\end{itemize}

\subsection{Deploying the fragment}

Once you have written your fragment, you still need to make \app{}
aware of its presence. This is done by exporting the fragment and
deploying it into the \app{} remote control.

There are different ways for installing your fragment into the \app{} remote
control, depending on the used AUT agent and the specific AUT. You are free to
use either the embedded AUT agent or the standalone AUT agent. Also your AUT
can be based upon the OSGi framework or not. The following table shows an
overview, where to deploy your fragment:

\begin{center}
\begin{tabular}{|c||c|c|}
\hline
~ & without OSGi & with OSGi\\
~ & (Swing, SWT) & (RCP, GEF)\\
\hline\hline
embedded & \multirow{2}{*}{\app{} client} & \multirow{4}{*}{AUT}\\
AUT agent & & \\
\hhline{--~}
standalone & standalone & \\
AUT agent  & AUT agent  & \\
\hline
\end{tabular}
\end{center}

It shows, in which case you usually deploy your fragment into
\begin{itemize}
  \item the \app{} client with a feature including your fragment,
  \item the standalone AUT agent by adding your fragment to its configuration,
        or
  \item the AUT with a feature including your fragment.
\end{itemize}

The configuration of the standalone AUT agent can be done by modifying the
file\\
\bxshell{server/configuration/config.ini}\\
There you have to append \bxshell{,Bundle\_name@start} at the end of the line
starting with \bxshell{osgi.bundles=}. Make sure, that the bundles are divided
by comma. Beside from the mentioned deploying methods, it is also possible
to install your fragment by using a p2 repository or the OSGi console.

You should be able to test your new component, if you have installed the
toolkit feature into the \app{} client and the fragment as described below.

\section{\app{} example extension}
\label{remoteControlExamples}

\app{} comes with source code examples for extending supported toolkits. The
examples can be found in the directory\\
\bxshell{examples/development/extension},\\
which contains the following sub folders:

\begin{description}
 \item[src] It contains some zip-files with example source code projects, which
            can be imported by Eclipse:
 \begin{itemize}
   \item \bxshell{RCPExtension.zip}\\
         A \app{} extension supporting \bxshell{Group} for SWT including client
         and remote control projects. After deploying these projects you should
         be able to test the \bxshell{Group} in RCP applications with \app{}.
   \item \bxshell{SwingAUT.zip}\\
         An AUT using \bxshell{JSlider} from Swing.
   \item \bxshell{SwingExtension.zip}\\
         The \app{} extension supporting \bxshell{JSlider} for Swing including
         client and remote control projects. After deploying these projects you
         should be able to test the \bxshell{JSlider} in the Swing example AUT
         with \app{}.
   \item \bxshell{SwingRendererExtension.zip}\\
         A \app{} remote control extension supporting a custom graphics
         component for Swing.
 \end{itemize}
 \item[AUT] It contains the binary file \bxshell{JSlider.jar}, which is a simple
 example AUT using the normally unsupported component \bxshell{JSlider}. After
 installing the \bxshell{JSlider} example extension from the \textbf{src}
 folder, \app{} will be able to test this new component.
\end{description}

\section{Migration steps}
If you have an existing implementation, which inherits from our old classes,
you have to change them. We have modified our \gdtesterclasses in a way, that they
do not use the concrete components anymore. Now the \gdtesterclasses take
advantage of the adapter class instead. If you want to migrate your old
classes, you must implement the new adapter described in the previous section.
