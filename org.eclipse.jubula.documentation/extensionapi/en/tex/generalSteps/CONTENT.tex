\chapter{Introduction}
\label{introduction}

\app{} starts, controls, and observes \gdauts using its server component. In
order for the \gdagent to know how to control each element of a GUI, we have
outfitted the \gdagent with a pluggable interface for graphic components. An
adapter factory containing one or more components must be implemented for and
deployed with the \gdaut. On the client site each GUI toolkit that \app{}
supports is described in a toolkit plug-in.

We have opened up an interface to our users to allow great and flexible
customizations. You can extend existing functionality, or provide support for
in-house graphic components by implementing your own so-called
\textbf{\gdtesterclasses.}

This handbook shows general steps for extending \app{}. In chapter
\ref{generalSteps} creating a toolkit extension is described. Apart from that
the chapter ends with an example and some hints for a migrating to the new API.
Last but not least chapter \ref{functions} describes how to create a custom
function, which can be used in \app{} tests.

\chapter{General Steps to take}
\label{generalSteps}

The following chapter describes the general steps to take for creating a toolkit
extension \app{} with custom defined components and actions. This chapter begins
with listing the requirements followed by showing the steps to take for
creating the \app{} client and server extension. The extension for the \app{}
client is described in section \ref{clientExtension} and the implementation
for the \app{} server extension in section \ref{serverExtension}.

Extension examples with source code can
be found in the sub directory\\
\bxshell{examples/development/extension/src/}\\
of a \app{} installation.

In general you always have to extend two parts of \app{}:
\begin{itemize}
\item The \app{} client by writing your own \textbf{Toolkit-Plugin}:\\
      This will tell the client, which new components and actions are available.
\item The \app{} remote control by writing your own \textbf{\gdtesterclasses:}\\
      % which by creating and putting it in the server or \app{}fragment-plugin
      This part actually performs the actions on the new components.
\end{itemize}

In this chapter normally all used directory names are located in the
installation directory of \app{}.

\section{Requirements}
To create your own \app{} extension, you need:
\begin{itemize}
\item \app{} 2.0 or later
\item Eclipse 3.4 or later
\item JDK 5.0
\item Write access in the following directories:\\
\bxshell{\MakeLowercase{\app{}}/plugins/}\\
\bxshell{server/plugins/}
\end{itemize}

\section{\app{} client extension}
\label{clientExtension}

This section shows how to develop the \app{} client extension. We describe the
steps to create the toolkit plug-in and how it can be exported into \app{}.

\subsection{Creating the toolkit plug-in for \app{}}

The following steps have to be done to extend the \app{} client:
\begin{enumerate}
 \item Create an Eclipse plug-in project and a corresponding feature project.
 \item Set \bxshell{\MakeLowercase{\app{}}/plugins/} as your
 target platform.
 \item Define the plug-in dependencies to the toolkit support plug-in.
 \item Enter the toolkit support plug-in in your toolkit plug-in project.
 \item Create your own toolkit provider class, e.g. named\\
 \bxshell{MyToolkitProvider}.
 \item Define and configure the toolkit extension at the extension point.
 \item Create the definition of your own toolkit in the file\\
 \bxshell{ComponentExtension.xml} by choosing one or more of the following
 possibilities:
 \begin{itemize}
  \item Extend existing \app{} components with new actions,
  \item derive new components from existing \app{} components, or
  \item define a new component.
 \end{itemize}
 \item Manage the i18n keys in the properties file.
\end{enumerate}

You will find projects in zip-files as a showcase for steps 1-8, which are
located in the directory\\
\bxshell{examples/development/extension/src}.\\
Each zip-file contains an example for a specific toolkit, e.g. a Swing example
extends the component \bxshell{JSlider} and contains a corresponding feature
project.

These example projects can be simply imported into your Eclipse workspace. After
importing set the target as described in step 2. All other steps have
already be done in the examples.

\subsection{Deploying the toolkit plug-in in \app{}}

After creating the toolkit feature, we describe the steps to take for deploying
it in the \app{} client. At first we export the toolkit feature to an update
site and then we use the update site to install the feature into \app{}.
 
\subsubsection{Export the toolkit feature to an update site}

\begin{enumerate}
\item In the package explorer, right click on the feature project 
 (e.g. org.eclipse.jubula.examples.extension.swing.feature) and
 select \bxmenu{Export...}{}{}.
\item Select \bxname{Deployable features} and click
\bxmenu{Next}{}{} in the dialog that appears.
\item In the next dialog, ensure that the check box next to the feature you wish
to export is selected in the \bxname{Available Features} area.
\item In the \bxname{Destination} tab, select the \bxname{Directory}
 field to define the location, where the update site of the feature should be
 exported to. Ensure, that the entered location is a writable directory. This
 directory serves as an update site, which can later be used to install your
 feature into \app{}.
\item In the \bxname{Options} tab, ensure that the check box named
\bxname{Package as individual JAR archives} is selected and click
\bxmenu{Finish}{}{}.
\end{enumerate}

\subsubsection{Install the toolkit feature from the update site}

\begin{enumerate}
\item Start \app{} and select from the main menu\\
\bxmenu{Help}{Install new software...}{}.
\item Click the \bxmenu{Add...}{}{}
button in the \bxname{Install} dialog that appears.
\item Click the \bxmenu{Local...}{}{} button in the \bxname{Add Repository} dialog
that appears
\item Navigate to the directory, that contains your update site and confirm your
selection.
\item Click \bxmenu{OK}{}{} to exit the \bxname{Add Repository} dialog.
 The active dialog should now be \bxname{Install}.
\item Ensure that the check box named \bxname{Group items by category} is
deselected. Your feature should be visible in the central table of the dialog.
\item Ensure that the check box next to your feature is selected and click
 \bxmenu{Next}{}{}.
\item Confirm the \bxname{Installation Details} by clicking the \bxmenu{Next}{}{}
 button again.
\item Accept the license agreement terms and click \bxmenu{Finish}{}{}.
\item A warning dialog may appear to warn you installing unsigned content.
 Click \bxmenu{OK}{}{} in this dialog, if the feature comes from a trusted
 source. This should be the case as long as you install your own feature.
 Then the installation process begins.
\item Click the \bxmenu{Restart Now}{}{} button to perform a restart of \app{},
 when a dialog appears, which suggests restarting \app{} in order to safely
 finish the update / installation.  After the restart your \app{} extension
 feature is installed.
\end{enumerate}

\section{\app{} server extension}
\label{serverExtension}

\gdauts{} are controlled by the server called \gdagent. If the embedded agent is
used, the \app{} client is also a server. For each component
that \app{} supports a \gdtesterclass must exist. This class implements the
test actions, that can be carried out on the component. You need to write a
fragment for your component, which contains the \gdtesterclass and a
corresponding adapter factory.

\subsection{What does a \gdtesterclass look like?}

The functionally important aspect of a \gdtesterclass is, that it
contains public methods for the \app{} test actions, which will appear in
the client. These methods are linked to testable actions within a user-defined
\app{} client plug-in. Each \app{} client plug-in provides an XML configuration
file, which defines the available methods with parameters, as well as
information for string externalization.

\subsection{Creating the fragment}

At first we must create a fragment, which uses one of the following bundles as
host:

\begin{itemize}
  \item \bxshell{org.eclipse.jubula.rc.swing} for extending the swing support
  \item \bxshell{org.eclipse.jubula.rc.swt} for extending the swt support
  \item \bxshell{org.eclipse.jubula.rc.rcp.e3.swt} for extending RCP support in Eclipse 3.x (without compat layer).
        This bundle can also be used as host for GEF extensions.
  \item \bxshell{org.eclipse.jubula.rc.rcp.e4.swt} for extending RCP support in Eclipse 4.x (including compat layer)
\end{itemize}

After this you can write your \gdtesterclasses and adapter. Adapters are used
throughout the whole Swing and SWT implementation. They wrap and specify
graphics component into a form we need for our \gdtesterclasses. You can write
your own adapter and/or reuse our existing adaptors. We recommend reusing our
adapters to take advantage of the already existing code. This is shown in the
swing extension example. If you are using adapter, there is a need that you
create a class which implements the
''org.eclipse.jubula.rc.common.adaptable.IAdapterFactory''. This class must be
located in the package ''org.eclipse.jubula.rc.common.adapter''. This
adapter factory is important to make your adapter usable by our system. You
also have to check, if the targeted type is an instance
''org.eclipse.jubula.rc.common.tester.adapter.IComponentAdapter'', because
the factory could also be used for the Swing text renderer adapter.
The adapter must at least implement the interface
''org.eclipse.jubula.rc.common.tester.adapter.IComponentAdapter'', but if you
want to support your component with the test functions on graphical components
level you should at least use the
''org.eclipse.jubula.rc.common.tester.adapter.IWidgetAdapter''.

You can write your own \gdtesterclasses, but if you only want to support a new
component with existing actions, you could use the adapter and one of our
existing \gdtesterclasses.

Please follow the following guidelines for your \gdtesterclasses:
\begin{itemize}
  \item Your build path must contain the following three JAR files:
  \bxshell{org.eclipse.jubula.rc.swing.jar}, \bxshell{org.eclipse.jubula.rc.common.jar}, and
  \bxshell{org.eclipse.jubula.tools.jar}, which contain our server classes and some utility classes.
  They are located in your \app{} installation directory under
  \bxshell{server/lib}.
  \item The class must be compatible with \bxname{Java 1.4}.
  \item It must either implement the following interface: \\
    ''org.eclipse.jubula.rc.common.tester.interfaces.ITester'',\\
	or be a subclass of ''org.eclipse.jubula.rc.common.tester.AbsstractUITester''
  \item The component must provide \textbf{public} methods for all implemented actions.
  \item Each method that implements an action must throw the following exception:
    org.eclipse.jubula.rc.common.exception.StepExecutionException
    Throw this exception to notify \app{}, if an action has failed.
\end{itemize}

Under ''InstallationDirectory/examples/development/extension/src''
you will find a \\ ''eclipseProjects\_ExampleSwingServerExtension.zip'' which contains
 an example \app{} Server Extension for the Swing component ''JSlider''.

Once you have written your Fragment-Plugin, you still need to make \app{}
aware of its presence. This is done by exporting the Fragment-Plugin and
deploying it into the plugins folder from \app{} or the \gdagent.
After you have done this you must change some configurations.

If you added the plugin to \app{} you must add the following line to the file
configuration/org.eclipse.equinox.simpleconfigurator/bundles.info:

\texttt{Bundle\_name,Bundle\_version,path\_to\_bundle,4,false}
e.g.:

If you only want to deploy it to the \gdagent you have to modify
the file ''configuration/config.ini'' by appending
\texttt{,Bundle\_name@start} at the end of the line, which begins with
''osgi.bundles=''.

Make sure that the bundles are divided by comma.

If you have installed the Feature and done the steps for the fragment, you
should be able to test your component. We are delivering a simple example
with \app{} this is described in the following section.

\section{\app{} example extension}
\app{} comes with a complete example extension implementation in source and binaries. 
This example extension extends \app{} for the Swing component ''JSlider''. After deploying the \app{} Client plug-in and the \app{} Server 
extension you should be able to test the Swing component ''JSlider'' at ''Graphics Component''-level with \app{}.
The example extension code and binaries can be found in the ''InstallationDirectory/examples/development/extension'':

\begin{itemize}
 \item AUT \\
 This directory contains a trivial example AUT which uses the originally unsupported component "JSlider". 
 After installing the extensions, your \app{} will be able to test this new component.
 \item src \\
 This directory contains several archive files which are all importable Eclipse projects:
 \begin{itemize}
   \item \bxshell{eclipseProjects\_ExampleSwingAUT.zip} \\
   This is the source code project for the example Swing AUT.
   \item \bxshell{eclipseProjects\_ExampleSwingClientExtension.zip} \\
   This is the source code project of the extension plug-in for the \app{} Client.
   \item \bxshell{eclipseProjects\_ExampleSwingServerExtension.zip} \\
   This is the source code project of the extension for the \app{} Server.
 \end{itemize}
 \item bin \\
 This directory contains the compiled sources as directly deployable units.
\end{itemize}

\section{Migration steps}
If you have an existing implementation, which inherits from our old classes,
you have to change them. We have modified our testerclasses in a way, that they
do not use the concrete components anymore. Now the testerclasses take
advantage of the adapter class instead. If you want to migrate your old
classes, you must implement the new adapter described in the previous section.
